Concepts
********


Software Product Line (SPL) Overview
====================================

Think of a **Software Product Line** like a toy factory that makes different types of toy cars. Each car is special - some are race cars, some are trucks, and others might be convertibles. 
But they all start from some common parts like wheels and engines. 
Just like using the same basic parts to make different toys, a Software Product Line uses common pieces of code to make different computer programs.
This way, making a new program is like building a new toy car but faster and easier because we already have the pieces we need!

A **Variant** is like choosing different decorations and features for your toy car. 
One car might be red with racing stripes and another might be a blue truck.
In computer programs, a variant is a version of the program that has something different or special about it, but it's still based on the same basic design.
It's like customizing your car or program to make it just the way you want it!

**Components** are like the building blocks you use to build something.
In our toy car, components could be the wheels, seats, or steering wheel - each part has its own job, and when we put them all together, we get a car!
In computer programs, components are pieces of the program that do certain jobs. We can use and combine these components to build different programs.

A **Feature Model** is like a big chart showing all the different parts and decorations you can choose from to make your toy car. It tells you which pieces fit together and how you can combine them to make different types of cars. In computer programs, a Feature Model helps us understand all the features (like colors, sizes, or special abilities) we can choose when we're making a new version of the program.

SPL
===

An SPL allows the building of various software variants from a common codebase. The central `CMakeLists.txt` in an SPL project outlines how to build a specific variant:

1. **Determining the Variant**: 
    * SPL-Core expects the ``VARIANT`` variable to be set and this shall be the subpath of the variant's directory relative to the SPL-Core ``variants`` directory
    * this is usually done by the user by providing the ``-DVARIANT=`` argument when calling ``cmake``
2. **Variant Configuration**: 
    * include the variant ``config.cmake`` file
3. **SPL-Core Integration**: 
    * fetch and include the SPL-Core CMake file
4. **Including Variant Relevant Parts**: 
    * include the variant ``parts.cmake`` file, detailing its components

For an example, see the ``CMakeLists.txt`` file generated by the :ref:`SPL project creator <use-project-creator>`.



Variant
=======

In SPL, a Variant is a specific version of the software that meets certain customer requirements.

.. attention::
    In SPL-Core a Variant is identified by its name which is the subpath of the variant's directory relative to the SPL-Core ``variants`` directory.

Here is an example of the variants directory with two variants:

.. code-block::

    variants
    └── my
        ├── var1
        │   ├── config.cmake
        │   ├── parts.cmake
        │   ├── config.txt
        │   └── ...
        └── var2
            ├── config.cmake
            ├── parts.cmake
            ├── config.txt
            └── ...


* ``config.cmake`` - variant specific CMake configuration, like the target architecture and toolchain.
* ``parts.cmake`` - contains the list of components that are part of the variant.
* ``config.txt`` - this is the feature selection of the variant. It is a KConfig file that contains the selected features of the variant.



Component
=========

A Component in SPL is a distinct, reusable unit with defined functionality and interfaces. These components, acting like software building blocks, simplify creating and managing the different SPL variants.

.. attention::
    In SPL-Core a Component is identified by its name which is the subpath of the component's directory relative to the project root directory.

Here is an example of the components directory with two components:

.. code-block::

    src
    ├── comp1
    │   ├── doc
    │   │   └── index.rst
    │   ├── src
    │   │   ├── comp1.c
    │   │   └── comp1.h
    │   ├── test
    │   │   └── test_comp1.cc
    │   └── CMakeLists.txt
    └── comp2
    │   ├── doc
    │   │   └── index.rst
    │   ├── src
    │   │   ├── comp2.c
    │   │   └── comp2.h
    │   ├── test
    │   │   └── test_comp2.cc
    │   └── CMakeLists.txt
    └── ...

1. **Component Documentation**: 
    * the ``doc`` directory contains the documentation of the component
    * if a component has a ``doc/index.rst`` file, spl-core will automatically generate a ``<component>_docs`` target that can be used to build the documentation
2. **Component Implementation**:
    * the ``src`` directory contains the source code of the component
    * the component relevant files are defined in the component ``CMakeLists.txt`` file
3. **Component Testing**:
    * the ``test`` directory contains the `GTest <https://github.com/google/googletest>`_ tests of the component
    * the component relevant test files are defined in the component ``CMakeLists.txt`` file
4. **Component Definition**
    * the component ``CMakeLists.txt`` file defines the component source and test files, and makes the component available with :ref:`spl_create_component <spl_create_component>`


Feature Model
=============

The Feature Model in SPL represents the organization of all potential features in a product line, showing how they relate and depend on each other. This model guides the creation of different SPL variants, ensuring that feature combinations are viable and consistent.

If a ``KConfig`` file is present in the root directory, SPL-Core will automatically parse it and generate the project configuration.

The variant specific configuration file is expected in the variant directory.
If a ``config.txt`` file is present in the variant directory, SPL-Core will automatically use it to override the default configuration values defined in the ``KConfig`` file.
